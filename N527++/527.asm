;==========================================
; ПРОГРАММА НАХОЖДЕНИЯ МАКСИМАЛЬНОГО ЭЛЕМЕНТА МАССИВА
;==========================================
; Программа запрашивает размер массива (от 1 до 100),
; затем запрашивает элементы массива один за другим,
; находит максимальный элемент в массиве,
; и выводит результат.
;
; Компиляция и сборка:
;   nasm -f elf32 527.asm -o 527.o
;   gcc -m32 527.o -o 527
;
; Запуск: ./527

extern printf
extern scanf
extern puts
extern getchar

;==========================================
; ОБЪЯВЛЕНИЕ ДАННЫХ ПРОГРАММЫ
;==========================================
section .data        ; Секция инициализированных данных
    prompt_size db 'Введите размер массива: ', 0    ; Сообщение для запроса размера массива
    prompt_element db 'Введите элемент: ', 0        ; Сообщение для запроса элемента массива
    result_msg db 'Максимальный элемент: %d', 10, 0 ; Формат вывода результата
    format_int db '%d', 0                           ; Формат для ввода целых чисел
    error_input db 'Ошибка: введите число!', 10, 0  ; Сообщение об ошибке ввода
    error_size db 'Ошибка: размер должен быть от 1 до 100!', 10, 0 ; Сообщение об ошибке размера

;==========================================
; ОБЪЯВЛЕНИЕ НЕИНИЦИАЛИЗИРОВАННЫХ ДАННЫХ
;==========================================
section .bss         ; Секция неинициализированных данных
    array resd 100   ; Массив для хранения до 100 целых чисел (4 байта на число)
    array_size resd 1 ; Переменная для хранения размера массива

;==========================================
; ИСПОЛНЯЕМЫЙ КОД ПРОГРАММЫ
;==========================================
section .text        ; Секция кода программы
    global main      ; Объявление глобальной метки main - точки входа в программу

;==========================================
; ГЛАВНАЯ ФУНКЦИЯ ПРОГРАММЫ
;==========================================
main:
    ;----------------------------------------
    ; ПОДБЛОК: Настройка стекового кадра
    ;----------------------------------------
    push ebp         ; Сохраняем базовый указатель
    mov ebp, esp     ; Устанавливаем новый базовый указатель
    
;==========================================
; БЛОК ЧТЕНИЯ РАЗМЕРА МАССИВА
; Запрашивает, считывает и проверяет размер массива
;==========================================
read_size:
    ;----------------------------------------
    ; ПОДБЛОК: Вывод приглашения для ввода размера
    ;----------------------------------------
    push prompt_size ; Передаем аргумент - строку приглашения
    call printf      ; Вызываем функцию printf
    add esp, 4       ; Очищаем стек (4 байта для одного аргумента)
    
    ;----------------------------------------
    ; ПОДБЛОК: Чтение размера массива
    ;----------------------------------------
    push array_size  ; Указатель на переменную для сохранения размера
    push format_int  ; Формат ввода для scanf
    call scanf       ; Вызываем функцию scanf
    add esp, 8       ; Очищаем стек (8 байт для двух аргументов)
    
    ;----------------------------------------
    ; ПОДБЛОК: Проверка успешности чтения
    ;----------------------------------------
    cmp eax, 1       ; Сравниваем результат scanf с 1 (число успешно прочитанных значений)
    je validate_size ; Если успешно - переходим к валидации
    
    ;----------------------------------------
    ; ПОДБЛОК: Обработка ошибки ввода
    ;----------------------------------------
    call clear_input_buffer ; Вызываем функцию очистки буфера ввода
    push error_input        ; Передаем сообщение об ошибке
    call printf             ; Вызываем функцию printf
    add esp, 4              ; Очищаем стек
    jmp read_size           ; Возвращаемся к запросу размера
    
;==========================================
; БЛОК ВАЛИДАЦИИ РАЗМЕРА МАССИВА
; Проверяет, что размер массива находится в допустимых пределах
;==========================================
validate_size:
    ;----------------------------------------
    ; ПОДБЛОК: Проверка диапазона размера (1-100)
    ;----------------------------------------
    mov eax, [array_size]  ; Загружаем размер массива в eax
    cmp eax, 1             ; Сравниваем с минимальным значением 1
    jl invalid_size        ; Если меньше 1 - ошибка
    cmp eax, 100           ; Сравниваем с максимальным значением 100
    jg invalid_size        ; Если больше 100 - ошибка
    jmp initialize_variables ; Если все хорошо - переходим к инициализации
    
    ;----------------------------------------
    ; ПОДБЛОК: Обработка некорректного размера
    ;----------------------------------------
invalid_size:
    push error_size        ; Передаем сообщение об ошибке размера
    call printf            ; Вызываем функцию printf
    add esp, 4             ; Очищаем стек
    jmp read_size          ; Возвращаемся к запросу размера
    
;==========================================
; БЛОК ИНИЦИАЛИЗАЦИИ ПЕРЕМЕННЫХ
; Подготавливает переменные для чтения массива
;==========================================
initialize_variables:
    ;----------------------------------------
    ; ПОДБЛОК: Инициализация счетчика
    ;----------------------------------------
    mov ecx, 0             ; Инициализируем счетчик цикла нулем
    
;==========================================
; БЛОК ЧТЕНИЯ ЭЛЕМЕНТОВ МАССИВА
; Запрашивает и считывает элементы массива один за другим
;==========================================
read_array_loop:
    ;----------------------------------------
    ; ПОДБЛОК: Проверка завершения чтения
    ;----------------------------------------
    cmp ecx, [array_size]   ; Сравниваем счетчик с размером массива
    jge find_max            ; Если все элементы прочитаны - переходим к поиску максимума
    
    ;----------------------------------------
    ; ПОДБЛОК: Запрос элемента массива
    ;----------------------------------------
    push ecx                ; Сохраняем значение счетчика в стеке
    push prompt_element     ; Передаем строку приглашения
    call printf             ; Вызываем функцию printf
    add esp, 4              ; Очищаем стек (один аргумент)
    
    ;----------------------------------------
    ; ПОДБЛОК: Чтение элемента массива
    ;----------------------------------------
    lea eax, [array + ecx*4] ; Вычисляем адрес элемента массива (индекс * 4 байта)
    push eax                 ; Указатель на переменную для сохранения элемента
    push format_int          ; Формат ввода для scanf
    call scanf               ; Вызываем функцию scanf
    add esp, 8               ; Очищаем стек (8 байт для двух аргументов)
    
    ;----------------------------------------
    ; ПОДБЛОК: Проверка успешности чтения
    ;----------------------------------------
    cmp eax, 1              ; Сравниваем результат scanf с 1
    je read_success         ; Если успешно - переходим к обработке успеха
    
    ;----------------------------------------
    ; ПОДБЛОК: Обработка ошибки ввода элемента
    ;----------------------------------------
    call clear_input_buffer ; Вызываем функцию очистки буфера ввода
    push error_input        ; Передаем сообщение об ошибке
    call printf             ; Вызываем функцию printf
    add esp, 4              ; Очищаем стек
    
    ; Возвращаем счетчик, но не увеличиваем его (для повторного ввода)
    pop ecx
    push ecx
    jmp read_array_loop     ; Повторяем ввод этого же элемента
    
    ;----------------------------------------
    ; ПОДБЛОК: Обработка успешного чтения
    ;----------------------------------------
read_success:
    pop ecx                 ; Восстанавливаем значение счетчика
    inc ecx                 ; Увеличиваем счетчик на 1
    jmp read_array_loop     ; Переходим к чтению следующего элемента
    
;==========================================
; БЛОК ПОИСКА МАКСИМАЛЬНОГО ЭЛЕМЕНТА
; Перебирает элементы массива и находит максимальный
;==========================================
find_max:
    ;----------------------------------------
    ; ПОДБЛОК: Инициализация поиска максимума
    ;----------------------------------------
    mov edx, [array]        ; Инициализируем максимум первым элементом
    
    ;----------------------------------------
    ; ПОДБЛОК: Инициализация цикла поиска
    ;----------------------------------------
    mov ecx, 1              ; Начинаем с индекса 1 (первый элемент уже в edx)
    
    ;----------------------------------------
    ; ПОДБЛОК: Цикл поиска максимального элемента
    ;----------------------------------------
max_loop:
    ;----------------------------------------
    ; ПОДБЛОК: Проверка завершения поиска
    ;----------------------------------------
    cmp ecx, [array_size]   ; Сравниваем счетчик с размером массива
    jge print_result        ; Если все элементы проверены - переходим к выводу результата
    
    ;----------------------------------------
    ; ПОДБЛОК: Сравнение текущего элемента с максимумом
    ;----------------------------------------
    mov eax, [array + ecx*4] ; Загружаем текущий элемент
    
    cmp eax, edx            ; Сравниваем с текущим максимумом
    jle not_greater         ; Если не больше - пропускаем обновление
    
    ;----------------------------------------
    ; ПОДБЛОК: Обновление максимума
    ;----------------------------------------
    mov edx, eax            ; Обновляем значение максимума
    
not_greater:
    ;----------------------------------------
    ; ПОДБЛОК: Переход к следующему элементу
    ;----------------------------------------
    inc ecx                 ; Увеличиваем счетчик на 1
    jmp max_loop            ; Повторяем цикл для следующего элемента
    
;==========================================
; БЛОК ВЫВОДА РЕЗУЛЬТАТА
; Выводит максимальный элемент массива
;==========================================
print_result:
    ;----------------------------------------
    ; ПОДБЛОК: Вывод сообщения с максимальным элементом
    ;----------------------------------------
    push edx                ; Передаем максимальное значение
    push result_msg         ; Передаем формат строки вывода
    call printf             ; Вызываем функцию printf
    add esp, 8              ; Очищаем стек (8 байт для двух аргументов)
    
    ;----------------------------------------
    ; ПОДБЛОК: Завершение программы
    ;----------------------------------------
    mov eax, 0              ; Устанавливаем код возврата 0 (успешное завершение)
    
    mov esp, ebp            ; Восстанавливаем указатель стека
    pop ebp                 ; Восстанавливаем базовый указатель
    ret                     ; Возвращаемся из функции main

;==========================================
; ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ: ОЧИСТКА БУФЕРА ВВОДА
; Очищает буфер ввода после неудачного вызова scanf
;==========================================
clear_input_buffer:
    ;----------------------------------------
    ; ПОДБЛОК: Настройка стекового кадра
    ;----------------------------------------
    push ebp                ; Сохраняем базовый указатель
    mov ebp, esp            ; Устанавливаем новый базовый указатель
    
    ;----------------------------------------
    ; ПОДБЛОК: Цикл очистки буфера
    ;----------------------------------------
clear_loop:
    call getchar            ; Вызываем функцию getchar для чтения символа
    cmp eax, 10             ; Сравниваем с символом новой строки (ASCII 10)
    je clear_done           ; Если это символ новой строки - завершаем очистку
    cmp eax, -1             ; Сравниваем с EOF (-1)
    je clear_done           ; Если это EOF - завершаем очистку
    jmp clear_loop          ; Иначе продолжаем чтение
    
clear_done:
    ;----------------------------------------
    ; ПОДБЛОК: Завершение функции
    ;----------------------------------------
    mov esp, ebp            ; Восстанавливаем указатель стека
    pop ebp                 ; Восстанавливаем базовый указатель
    ret                     ; Возвращаемся из функции

;==========================================
; МЕТАДАННЫЕ
;==========================================
section .note.GNU-stack noalloc noexec nowrite  ; Метаданные для отключения исполняемого стека
